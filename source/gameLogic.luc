module gameLogic (
    input clk,  // clock
    input rst,  // reset
    input currentMap[16][16],
    input p1ButtonInput[4], // Indicates the buttons pressed by p1
    input p2ButtonInput[4], // Indicates the buttons pressed by p2
    input p1Ready[1], // indicates if p1 ready button was pressed
    input p2Ready[1], // indicates if p2 ready button was pressed
    input levelButton,
    input p1ScoreIn[4],
    input p2ScoreIn[4],
    output nextMap[16][16],
    output p1ScoreOut[4],
    output p2ScoreOut[4],
    output p1Lost[1],
    output p2Lost[1]

  ) {
    .clk(clk){
    .rst(rst){
      levelButtonState levelButtonState;
      //powerButtonState powerButtonState;
      fsm playing(.clk(clk), #INIT(NOT_PLAYING)) = {NOT_PLAYING, PLAYING};
      fsm p1State(.clk(clk), #INIT(R)) = {U, D, L, R};
      fsm p2State(.clk(clk), #INIT(U)) = {U, D, L, R};
      dff timeToUpdateMap[26]; // When this value reaches difficultyLevel, update the map
      dff p1PositionX[4]; // Indicates [i][j] position of p1
      dff p1PositionY[4]; // Indicates [i][j] position of p1
      dff p2PositionX[4]; // Indicates [i][j] position of p1
      dff p2PositionY[4]; // Indicates [i][j] position of p2
      dff level[26] (#INIT(b10111110101111000010000000));
      }
    }

  always {
  levelButtonState.button = ~levelButton;
  //powerButtonState.button = ~powerButton;
  p1ScoreOut = p1ScoreIn;
  p2ScoreOut = p2ScoreIn;
  p1Lost = b0;
  p2Lost = b0;
  nextMap = // initialize map. 1 indicates off, while 0 indicated on
              {c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};
  case(playing.q){
      playing.NOT_PLAYING:
      nextMap = // initialize map. 1 indicates off, while 0 indicated on
              {c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
               c{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};
     p1PositionX.d = b1111;
     p1PositionY.d = b0111;
     p2PositionX.d = b0000;
     p2PositionY.d = b0111;
     timeToUpdateMap.d = b00000000000000000000000000;
     p1State.d = p1State.R;
     p2State.d = p2State.L;          
     if (p1Ready == b0 && p2Ready == b0){
       playing.d = playing.PLAYING;}
     if (levelButtonState.count == b1){
        if(level.q == b10111110101111000010000000){
          level.d = b01011111010111100001000000;
          }
        else if(level.q == b01011111010111100001000000){
          level.d = b00010011000100101101000000;
          }
        else if(level.q == b00010011000100101101000000){
          level.d = b10111110101111000010000000;
          }
        }
     playing.PLAYING:
        timeToUpdateMap.d = timeToUpdateMap.q + b1;
        nextMap = currentMap;
        if (timeToUpdateMap.q < level.q - b1) {
        timeToUpdateMap.d = timeToUpdateMap.q + b1; // increase timer
        nextMap = currentMap; // nextMap doesn't change
        // player input is as follows: 
        // format is UP,DOWN,LEFT,RIGHT
        // so b1011 means that the player pressed DOWN
        if (p1ButtonInput[3] == b0){
          p1State.d = p1State.U;}
        else if (p1ButtonInput[2] == b0){
          p1State.d = p1State.D;}
        else if (p1ButtonInput[1] == b0){
          p1State.d = p1State.L;}
        else if (p1ButtonInput[0] == b0){
          p1State.d = p1State.R;}
        if (p2ButtonInput[3] == b0){
          p2State.d = p2State.U;}
        else if (p2ButtonInput[2] == b0){
          p2State.d = p2State.D;}
        else if (p2ButtonInput[1] == b0){
          p2State.d = p2State.L;}
        else if (p2ButtonInput[0] == b0){
          p2State.d = p2State.R;}
        }
        else if (timeToUpdateMap.q == level.q - b1){
          case (p1State.q) {
          p1State.U:
            p1PositionY.d = p1PositionY.q + b1;
            if (p1PositionY.q == b1111) {
              playing.d = playing.NOT_PLAYING;
              if(p2ScoreIn == b1001){
                p2ScoreOut = b0000;
                }
              else{
                p2ScoreOut = p2ScoreIn + b1;
                  }
              p1Lost = b1;
            }
          p1State.D:
            p1PositionY.d = p1PositionY.q - b1;
            if (p1PositionY.q == b0000) {
              playing.d = playing.NOT_PLAYING;
              if(p2ScoreIn == b1001){
                p2ScoreOut = b0000;
                }
              else{
                p2ScoreOut = p2ScoreIn + b1;
                  }
              p1Lost = b1;
            }
          p1State.L:
            p1PositionX.d = p1PositionX.q + b1;
            if (p1PositionX.q == b1111) {
              playing.d = playing.NOT_PLAYING;
              if(p2ScoreIn == b1001){
                p2ScoreOut = b0000;
                }
              else{
                p2ScoreOut = p2ScoreIn + b1;
                  }
              p1Lost = b1;
            }
          p1State.R:
            p1PositionX.d = p1PositionX.q - b1;
            if (p1PositionX.q == b0000) {
              playing.d = playing.NOT_PLAYING;
              if(p2ScoreIn == b1001){
                p2ScoreOut = b0000;
                }
              else{
                p2ScoreOut = p2ScoreIn + b1;
                  }
              p1Lost = b1;
            }
        }
        
        // get the new position of p2 and check if they fail the boundary requirements
        case (p2State.q) {
          p2State.U:
            p2PositionY.d = p2PositionY.q + b1;
            if (p2PositionY.q == b1111) {
              playing.d = playing.NOT_PLAYING;
              if(p1ScoreIn == b1001){
                p1ScoreOut = b0000;
                }
              else{
                p1ScoreOut = p1ScoreIn + b1;
                  }
              p2Lost = b1;
            }
          p2State.D:
            p2PositionY.d = p2PositionY.q - b1;
            if (p2PositionY.q == b0000) {
              playing.d = playing.NOT_PLAYING;
              if(p1ScoreIn == b1001){
                p1ScoreOut = b0000;
                }
              else{
                p1ScoreOut = p1ScoreIn + b1;
                  }
              p2Lost = b1;
            }
          p2State.L:
            p2PositionX.d = p2PositionX.q + b1;
            if (p2PositionX.q == b1111) {
              playing.d = playing.NOT_PLAYING;
              if(p1ScoreIn == b1001){
                p1ScoreOut = b0000;
                }
              else{
                p1ScoreOut = p1ScoreIn + b1;
                  }
              p2Lost = b1;
            }
          p2State.R:
            p2PositionX.d = p2PositionX.q - b1;
            if (p2PositionX.q == b0000) {
              playing.d = playing.NOT_PLAYING;
              if(p1ScoreIn == b1001){
                p1ScoreOut = b0000;
                }
              else{
                p1ScoreOut = p1ScoreIn + b1;
                  }
              p2Lost = b1;
            }
        }
        }
        else if (timeToUpdateMap.q == level.q){
          timeToUpdateMap.d = b00000000000000000000000000;
          if (p1PositionX.q == p2PositionX.q && p1PositionY.q == p2PositionY.q){
          playing.d = playing.NOT_PLAYING;
          if(p1ScoreIn == b1001){
                p1ScoreOut = b0000;
                }
              else{
                p1ScoreOut = p1ScoreIn + b1;
                  }
          if(p2ScoreIn == b1001){
                p2ScoreOut = b0000;
                }
              else{
                p2ScoreOut = p2ScoreIn + b1;
                  }
          p1Lost = b1;
          p2Lost = b1;            
          }
          else if (currentMap[p1PositionY.q][p1PositionX.q] == 0 && currentMap[p2PositionY.q][p2PositionX.q] == 0){
          playing.d = playing.NOT_PLAYING;
          if(p1ScoreIn == b1001){
                p1ScoreOut = b0000;
                }
              else{
                p1ScoreOut = p1ScoreIn + b1;
                  }
          if(p2ScoreIn == b1001){
                p2ScoreOut = b0000;
                }
              else{
                p2ScoreOut = p2ScoreIn + b1;
                  }
          p1Lost = b1;
          p2Lost = b1;
          }
          else if (currentMap[p1PositionY.q][p1PositionX.q] == 0){
          playing.d = playing.NOT_PLAYING;
          if(p2ScoreIn == b1001){
                p2ScoreOut = b0000;
                }
              else{
                p2ScoreOut = p2ScoreIn + b1;
                  }
          p1Lost = b1;
          }
          else if (currentMap[p2PositionY.q][p2PositionX.q] == 0){
          playing.d = playing.NOT_PLAYING;
          if(p1ScoreIn == b1001){
                p1ScoreOut = b0000;
                }
              else{
                p1ScoreOut = p1ScoreIn + b1;
                  }
          p2Lost = b1;
          }
          else{
          nextMap[p1PositionY.q][p1PositionX.q] = 0;
          nextMap[p2PositionY.q][p2PositionX.q] = 0;}
        }
       else{
        }
    }
    
  }
}
